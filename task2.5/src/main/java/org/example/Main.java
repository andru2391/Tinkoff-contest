package org.example;

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] firstInput = scanner.nextLine().split(" ");
        int n = Integer.parseInt(firstInput[0]);
        long s = Long.parseLong(firstInput[1]);
        String[] secondInput = scanner.nextLine().split(" ");
        scanner.close();
        int[] a = new int[n];

        for (int i = 0; i < n; i++) {
            a[i] = Integer.parseInt(secondInput[i]);
        }

        long[] P = new long[n + 1];
        P[0] = 0;

        for (int i = 0; i < n; i++) {
            P[i + 1] = P[i] + a[i];
        }

        int[] L = new int[n + 1];
        int left = 1;

        for (int i = 1; i <= n; i++) {
            while (left <= i && P[i] - P[left - 1] > s) {
                left++;
            }
            L[i] = left;
        }

        long totalBoundaries = 0;
        int t = 0;

        for (int i = 1; i < n; i++) {
            long Q = P[i + 1] - s;

            while (t <= i + 1 && t < P.length && P[t] < Q) {
                t++;
            }
            int y = t - 1;
            int c1 = 0;
            if (P[i + 1] - P[L[i] - 1] > s) {
                c1 = 1;
            }
            int low = L[i] + 1;
            int high = i;
            int limit = y + 1;
            int c2 = 0;
            if (low <= high) {
                if (limit >= low) {
                    int realHigh = Math.min(high, limit);
                    if (realHigh >= low) {
                        c2 = realHigh - low + 1;
                    }
                }
            }
            int countBi = L[i] * c1 + c2;
            totalBoundaries += (long) (n - i) * countBi;
        }

        long subRange = (long) n * (n + 1) / 2;
        long result = totalBoundaries + subRange;

        System.out.println(result);

    }
}


        /*На день рождения Дмитрию подарили брусок! На данном бруске Дмитрий обнаружил n - 1 засечку. Данные засечки разбивают брусок на n сегментов. Длина i-го сегмента равняется аi. Дмитрию хочется распилить брусок на маленькие части. Распилы разрешается делать только в местах, в которых есть засечки (но необязательно делать распил там, где есть засечка). Часть считается маленькой, если ее длина не превосходит s. При этом Дмитрию хочется тратить как можно меньше усилий, поэтому он хочет делать как можно меньше распилов. Не успев приступить к делу, Дмитрий задумался: а если бы ему дали не целый брусок, а его подотрезок, который засечками делился бы на части с длинами аl, аl+1, ... , аr-1, аr, то на какое количество частей он должен бы был распилить брусок, чтобы каждая часть была маленькая? Такое значение обозначим как f(l, r).Подумайте вместе с Дмитрием! Посчитайте, чему равняется (сигма от l-1 до n)(сигма от r-l до n)f(l, r).

        Формат входных данных:
        Первая строка содержит число n (1 <= n <= 250000) и s (1 <= s <= 10^15) - количество сегментов, на которые брусок разбит засечками, и максимальную возможную длину куска, чтобы он все еще считался маленьким. Вторая строка содержит значения a1, a2, ..., an (1 <= ai <= min(s, 10^9)), где ai - длина i-го сегмента.

        Формат выходных данных:
        Выведите значение (сигма от l-1 до n)(сигма от r-l до n)f(l, r)где f(l, r) - минимальное количество частей, на которое должен быть разбит брусок из сегментов с длинами al, al+1, ... , аr, чтобы каждая из частей имела длину не более s.

        Замечание про минимальное разбиение:
        Если а = [3, 2, 2] и s = 4, то минимальным по размеру будет разбиение на части [3] и [2, 2]. Если а = [5, 1, 5, 1, 5, 1, 5] и s = 5, то минимальным по размеру будет разбиение на части [5], [1], [5], [1],[5], [1], [5].

        Комментарий про пример:
        f(1, 1) + f(1, 2) + f(1, 3) + f(2, 2) + f(2, 3) + f(3, З) = 1 + 1 + 2 + 1 + 2 + 1 = 8.

        Примеры данных:
        Ввод:
        3 3
        1 2 3
        Вывод:
        8*/
